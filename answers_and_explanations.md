# 정답 및 해설

이 문서에는 각 챕터의 확인 문제에 대한 정답과 상세한 해설이 포함되어 있습니다.

---

## Chapter 2: 메모리 아키텍처와 데이터 그리드

### 문제 1
**정답: 2. Off-Heap**

**해설**: Ignite는 JVM의 GC(Garbage Collection)에 의해 성능이 예측 불가능해지는 것을 방지하기 위해, 대부분의 데이터를 GC의 관리 대상이 아닌 **Off-Heap** 메모리 영역에 저장하는 것을 권장합니다. 이를 통해 GC로 인한 'Stop-the-world' 현상을 최소화하고 안정적인 성능을 확보할 수 있습니다. On-Heap은 매우 작은 양의 데이터를 빠르게 처리할 때 제한적으로 사용되며, Native Persistence는 영속성을 위한 디스크 저장 계층입니다.

### 문제 2
**정답: 1, 3, 4**

**해설**:
1.  **(정답)** `REPLICATED` 캐시는 이름 그대로 데이터 전체를 클러스터의 모든 노드에 복제하여 저장합니다.
2.  (오답) 대용량 데이터 저장과 확장성에 유리한 것은 데이터를 분산 저장하는 `PARTITIONED` 캐시입니다. `REPLICATED` 캐시는 모든 노드에 데이터를 복제하므로 대용량 데이터에는 부적합합니다.
3.  **(정답)** 데이터를 수정할 때마다 모든 노드에 변경 사항을 동기화해야 하므로, 읽기 성능에 비해 쓰기 성능은 상대적으로 저하됩니다.
4.  **(정답)** 어떤 노드에서든 메모리에서 바로 데이터를 읽을 수 있으므로 조회 속도가 매우 빠릅니다.

### 문제 3
**정답: 2. 파티셔닝 (Partitioning)**

**해설**: **파티셔닝**은 대용량 데이터를 여러 개의 작은 조각(파티션)으로 나누어 클러스터 내의 여러 노드에 분산하여 저장하는 핵심 기술입니다. 이를 통해 시스템 전체의 저장 용량을 늘리고 부하를 분산시키는 확장성을 확보할 수 있습니다. 복제(Replication)는 데이터의 안정성을 위해 파티션의 복사본을 만드는 기술이며, 영속성(Persistence)은 데이터를 디스크에 저장하는 기능입니다.

---

## Chapter 3: Java 애플리케이션과 Ignite 통합

### 문제 1
**정답: 4. 클라이언트 노드 (Client Node)**

**해설**: **클라이언트 노드**는 데이터를 직접 저장하거나 연산을 수행하지 않고, 원격으로 서버 노드에 연결하여 작업 요청만 보내는 경량화된 노드입니다. 애플리케이션은 보통 클라이언트 노드를 통해 클러스터에 안전하게 접근합니다. 서버 노드는 실제 데이터를 저장하고 연산을 처리하는 핵심 노드입니다.

### 문제 2
**정답: 1, 3**

**해설**:
1.  **(정답)** `get(key)`는 키에 해당하는 값을 조회하는 표준 읽기 메서드입니다.
2.  (오답) Ignite Cache API에는 `create()`라는 메서드가 없습니다. 데이터 생성은 `put()`을 사용합니다.
3.  **(정답)** `put(key, value)`는 해당 키가 없으면 새로운 데이터를 생성(Create)하고, 키가 이미 존재하면 값을 덮어써서 수정(Update)하는 역할을 모두 수행합니다.
4.  (오답) 데이터 삭제 메서드는 `delete(key)`가 아닌 `remove(key)`입니다.

### 문제 3
**정답: 3. 트랜잭션 (Transaction)**

**해설**: **트랜잭션**은 여러 개의 개별적인 작업을 하나의 논리적 실행 단위로 묶는 것입니다. 이 단위 내의 모든 작업이 성공해야만 최종적으로 데이터 변경이 반영되며(Commit), 하나라도 실패하면 모든 작업이 취소됩니다(Rollback). 이를 통해 데이터의 원자성과 일관성을 보장합니다.

---

## Chapter 4: 웹 애플리케이션 통합 (REST API & JavaScript)

### 문제 1
**정답: 3. REST API**

**해설**: 웹 브라우저나 JavaScript 환경에서는 표준 HTTP 프로토콜을 사용하는 **REST API**를 통해 Ignite에 접근하는 것이 가장 일반적이고 편리한 방법입니다. 별도의 드라이버나 라이브러리 설치 없이 `fetch` API 등을 사용하여 쉽게 데이터를 주고받을 수 있습니다. 다른 클라이언트들은 특정 프로그래밍 언어나 환경에 종속적입니다.

### 문제 2
**정답: 2, 3**

**해설**:
1.  (오답) `useEffect`는 데이터 fetching과 같은 부수 효과를 처리하는 React의 핵심 훅이므로, 제거하는 것은 해결책이 아닙니다.
2.  **(정답)** 가장 근본적인 해결책은 서버(Ignite) 측에서 CORS 설정을 통해 특정 출처(Origin, 예: `http://localhost:3000`)의 요청을 허용해주는 것입니다.
3.  **(정답)** 개발 환경에서 많이 사용하는 방법으로, React 개발 서버의 프록시 기능을 이용해 API 요청을 같은 도메인에서 나가는 것처럼 중계하여 브라우저의 CORS 정책을 우회할 수 있습니다.
4.  (오답) `axios`는 `fetch`보다 편리한 기능을 제공하는 HTTP 클라이언트 라이브러리일 뿐, CORS 정책 문제를 자동으로 해결해주지는 않습니다.

### 문제 3
**정답: 2. WebSocket**

**해설**: **웹소켓**은 서버와 클라이언트 간의 양방향 통신 채널을 열어두는 기술입니다. 이를 통해 서버는 데이터 변경과 같은 이벤트가 발생했을 때 즉시 클라이언트에게 메시지를 푸시(Push)할 수 있어, 실시간 UI 업데이트에 가장 적합합니다. REST API 폴링은 클라이언트가 주기적으로 서버에 요청을 보내야 하므로 실시간성이 떨어지고 비효율적입니다.

---

## Chapter 5: 성능 최적화와 모니터링

### 문제 1
**정답: 2. 인덱스 (Index)**

**해설**: **인덱스**는 데이터베이스 테이블의 특정 컬럼(필드)에 대한 검색 속도를 비약적으로 향상시키는 자료구조입니다. SQL 쿼리에서 `WHERE` 절의 조건으로 사용되는 필드에 인덱스를 생성하지 않으면, Ignite는 조건에 맞는 데이터를 찾기 위해 모든 데이터를 일일이 확인(Full Scan)해야 하므로 성능이 크게 저하됩니다.

### 문제 2
**정답: 1, 2, 3**

**해설**:
1, 2. **(정답)** `JConsole`과 `VisualVM`은 Java에서 제공하는 표준 JMX 클라이언트로, Ignite 노드의 상세한 내부 상태를 실시간으로 모니터링할 수 있습니다.
3.  **(정답)** `Ignite Visor CLI`는 Ignite가 자체적으로 제공하는 커맨드 라인 기반의 강력한 모니터링 및 관리 도구입니다.
4.  (오답) Node.js는 Ignite를 모니터링하는 도구가 아니라, REST API 등을 통해 Ignite를 활용하는 클라이언트 애플리케이션을 만드는 데 사용되는 런타임 환경입니다.

### 문제 3
**정답: 2. 데이터 지역성 (Data Affinity)**

**해설**: **데이터 지역성(또는 Affinity Collocation)**은 연관된 데이터(예: 주문과 주문 항목, 사용자와 사용자의 게시물)를 동일한 노드에 함께 배치하는 기술입니다. 이를 통해 여러 데이터를 조인(Join)할 때 네트워크를 통한 데이터 이동 없이 노드 내에서 로컬 연산으로 처리할 수 있어 쿼리 성능을 크게 향상시킬 수 있습니다.

